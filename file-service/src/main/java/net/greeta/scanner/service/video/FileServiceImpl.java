package net.greeta.scanner.service.video;

import com.fasterxml.jackson.databind.ObjectMapper;
import net.greeta.scanner.config.ObjectStorageConfiguration;
import net.greeta.scanner.config.StreamConfig;
import net.greeta.scanner.data.file.FileSummary;
import net.greeta.scanner.exception.DoesNotExist;
import net.greeta.scanner.models.User;
import net.greeta.scanner.models.file.*;
import net.greeta.scanner.repository.FileEventResultRepository;
import net.greeta.scanner.repository.user.UserRepository;
import net.greeta.scanner.repository.file.FileEventRepository;
import net.greeta.scanner.repository.file.FileRepository;
import net.greeta.scanner.service.storage.ObjectStorageService;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.util.List;
import java.util.UUID;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.dao.OptimisticLockingFailureException;
import org.springframework.retry.annotation.Backoff;
import org.springframework.retry.annotation.Retryable;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.servlet.mvc.method.annotation.StreamingResponseBody;

@Service
public class FileServiceImpl implements FileService {
  @Autowired UserRepository userRepository;
  @Autowired
  FileRepository fileRepository;
  @Autowired
  FileEventRepository eventRepository;
  @Autowired ObjectMapper objectMapper;
  @Autowired
  FileEventResultRepository resultRepository;
  @Autowired
  ObjectStorageService objectStorageService;
  @Autowired
  ObjectStorageConfiguration objectStorageConfiguration;
  @Autowired
  StreamConfig streamConfig;
  private static final Logger logger = LoggerFactory.getLogger(FileService.class);

  @Override
  @Transactional(rollbackFor = Exception.class)
  public FileSummary createFromObjectStorage(String userName, String title, String objectName) throws Exception {
    User user = userRepository.getByUserName(userName).orElseThrow();
    File file = new File(user, title);
    file = fileRepository.saveAndFlush(file);
    FileEvent event =
        new FileEvent(file.getId().toString(), user.getId().toString(), Operation.PROCESS);
    event.setSource("minio.bucket.store://" + objectName);
    eventRepository.save(event);
    return new FileSummary(file);
  }

  @Override
  @Transactional(readOnly = true)
  public StreamingResponseBody m3u8Index(UUID fileId) throws DoesNotExist {
    // User user = userRepository.findById(userId).orElseThrow();
    // todo: check accessible ?
    File file =
        fileRepository
            .findById(fileId)
            .orElseThrow(() -> new DoesNotExist("target file does not exist !"));
    if (file.getStatus().equals(FileStatus.PROCESSING))
      throw new DoesNotExist("target file is still under processing !");

    String tsPrefix = streamConfig.getPrefix() + fileId + "/";
    try {
      List<String> files =
          objectStorageService.listFiles(
              objectStorageConfiguration.getStreamBucket(), file.getPath());
      String target =
          files.stream().filter((f) -> f.endsWith("index.m3u8")).findFirst().orElseThrow();
      BufferedReader reader =
          new BufferedReader(
              new InputStreamReader(
                  objectStorageService.readFile(
                      objectStorageConfiguration.getStreamBucket(), target)));
      return outputStream -> {
        try {
          String line;
          while ((line = reader.readLine()) != null) {
            if (line.endsWith(".ts")) line = tsPrefix + line;
            outputStream.write(line.getBytes());
            outputStream.write(System.lineSeparator().getBytes());
          }
          outputStream.flush();
        } catch (IOException e) {
          e.printStackTrace();
        } finally {
          reader.close();
          outputStream.close();
        }
      };
    } catch (Exception e) {
      e.printStackTrace();
      throw new DoesNotExist("cannot retrieve target m3u8 !");
    }
  }

  @Override
  @Transactional(readOnly = true)
  public StreamingResponseBody ts(UUID fileId, String filename) throws DoesNotExist {
    // User user = userRepository.findById(userId).orElseThrow();
    // todo: check accessible ?
    File file =
        fileRepository
            .findById(fileId)
            .orElseThrow(() -> new DoesNotExist("target file does not exist !"));
    if (file.getStatus().equals(FileStatus.PROCESSING))
      throw new DoesNotExist("target file is still under processing !");

    try {
      InputStream inputStream =
          objectStorageService.readFile(
              objectStorageConfiguration.getStreamBucket(),
              "user/" + file.getOwner().getId() + "/file/" + fileId + "/" + filename);
      return outputStream -> {
        try {
          byte[] buffer = new byte[1024];
          int bytesRead;
          while ((bytesRead = inputStream.read(buffer)) != -1) {
            outputStream.write(buffer, 0, bytesRead);
          }
          outputStream.flush();
        } catch (IOException e) {
          e.printStackTrace();
        } finally {
          inputStream.close();
          outputStream.close();
        }
      };
    } catch (Exception e) {
      e.printStackTrace();
      throw new DoesNotExist("cannot retrieve target ts !");
    }
  }

  @Override
  public List<FileSummary> list() {
    return fileRepository.findAll().stream().map(FileSummary::new).toList();
  }

  @Override
  @Transactional(readOnly = true)
  public FileSummary profile(UUID fileId) throws DoesNotExist {
    // User user = userRepository.findById(userId).orElseThrow();
    // todo: check accessible ?
    File file =
        fileRepository
            .findById(fileId)
            .orElseThrow(() -> new DoesNotExist("target file does not exist !"));
    return new FileSummary(file);
  }

  @Override
  @Transactional(rollbackFor = Exception.class)
  @Retryable(retryFor = OptimisticLockingFailureException.class, backoff = @Backoff(delay = 100))
  public void onFileEventComplete(EventResult result) throws Exception {
    File file = fileRepository.findById(UUID.fromString(result.getFileId())).orElse(null);
    if (file == null) return;
    // check is processed before to prevent duplicated
    FileEventResult r = resultRepository.findById(result.getId()).orElse(null);
    if (r != null) {
      logger.info("duplicated event result !");
      return;
    }
    r = new FileEventResult(result);
    // if operation fail(process or delete)
    if (ResultStatus.FAIL.equals(result.getStatus())) {
      file.setStatus(FileStatus.ERROR);
      file.setEventResult(objectMapper.writeValueAsString(result));
      fileRepository.save(file);
      resultRepository.save(r);
      return;
    }
    // if operation success
    if (Operation.DELETE.equals(result.getOperation())
        && FileStatus.DELETING.equals(file.getStatus())) {
      fileRepository.delete(file);
      resultRepository.save(r);
    } else if (Operation.PROCESS.equals(result.getOperation())
        && FileStatus.PROCESSING.equals(file.getStatus())) {
      file.setStatus(FileStatus.READY);
      file.setPath(result.getDetail());
      file.setEventResult(objectMapper.writeValueAsString(result));
      fileRepository.save(file);
      resultRepository.save(r);
    } else {
      throw new RuntimeException(
          "unexpected File:%s, FileEventResult:%s".formatted(file, result));
    }
  }
}
